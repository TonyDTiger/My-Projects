# Quadcopter Project

The objective of this project is to develop a controller to control a 6 Degrees of Freedom (DOF) quadcopter based on a common set of requirements.

---

## Requirements

### System level
* The system shall have the ability to track a desired position within ±0.5 m in horizontal axes and ±0.25 m in altitude under nominal conditions
* The system shall have a pointing accuracy as defined below:
    * Roll/pitch tracking error RMS ≤ 2° (0.0345 rad)
    * Yaw tracking error RMS ≤ 5° (0.0875 rad)

### Mechnical level
* The quadcopter shall have a mass of 1.5 kg
* The quadcopter shall have a moments of inertia of: $I_{xx}$ = 0.03 $kgm^2$, $I_{yy}$ = 0.03 $kgm^2$, $I_{zz}$ = 0.05 $kgm^2$
* The quadcopter shall have rotor arm lengths of 0.225 m each

### Actuator level
* The quadcopter shall have the rotors in a cross-configuration, with the first rotor in between the body X and Y axes
* The quadcopter total thrust shall have a 2:1 thrust-to-weight ratio, with each rotor having the same thrust capability
* The rotors shall have a thrust coefficient ($C_{L}$)of 2.3E-5 $\frac{N}{(\frac{rad}{s})^2}$ and a moment drag ($C_{D}$) coefficient of 7.8E-7 $\frac{Nm}{(\frac{rad}{s})^2}$

### Controller level
* Gain and phase margins shall be ≥6 dB and ≥45°, respectively
* The control algorithm shall run at a 50 Hz update rate
* The controller shall handle sensor-to-actuator latency ≤ 20 ms (end-to-end)
* The controller shall not demand thrust or torque exceeding 100% of rotor limits during nominal operation.

## Overview

A quadcopter is a 6-DOF rigid body with four independent rotors. Its dynamics can be split into:

- Translational dynamics (position and velocity in 3D space).
- Rotational dynamics (attitude and angular rates).
- Control inputs (thrusts generated by each rotor).

We model the quadcopter system parameters relative the body frame (attached to the quadcopter) and model its motion relative to an inertial frame (Earth-fixed, North-East-Down).

<img width="678" height="519" alt="quadcopter_body_frame" src="https://github.com/user-attachments/assets/7e5b6762-ec1f-4a5e-b721-eb3c31cc4c0b" />

- Rotor 1: $(x_1,y_1) = \big(\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$  (between +X and +Y)  
- Rotor 2: $(x_2,y_2) = \big(-\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$ (between −X and +Y)  
- Rotor 3: $(x_3,y_3) = \big(-\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between −X and −Y)  
- Rotor 4: $(x_4,y_4) = \big(\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between +X and −Y)

The arm length is given as $l$.

---

## Assumptions

To break down and help simplify the problem. It is key to define some assumptions.

* The quadcopter system is time invariant (i.e. no change in mass properties or rotor thrust capabilities)
* The quadcopter is a rigid body (i.e. no structural flexible modes)
* The quadcopter states are fully controllable and observable (note this can be assessed by forming the controllability and observability Gramian matrices)

## State and System Parameter Definition

We define the state vector:

$$
\mathbf{x} =
\begin{bmatrix}
x & y & z & u & v & w & \phi & \theta & \psi & p & q & r
\end{bmatrix}^T
$$

where:
- $x,y,z$: position vector components, inertial frame
- $u,v,w$: translational velocity components, body-frame
- $\phi, \theta, \psi$: Euler roll pitch, yaw angles
- $p,q,r$: rotational velocity components, body-frame

Mass properties of the quadcopter are: mass $m$ and principal moments of inertia $I_x,I_y,I_z$. Gravitational acceleration constant is represented as: $g$.

---

## Control Inputs

- Each rotor produces thrust $f_i$ along the body $+z_b$ axis (opposing gravity when pitched/rolled to tilt the thrust vector).
- Arm length from the CG to each rotor is $l$.
- Reaction torques (about $z_b$) due to rotor drag and the spin pattern above are calculated as shown below,

$$
\tau_z = \frac{C_{D}}{C_{L}} (f_1 - f_2 + f_3 - f_4)
$$

---

## Nonlinear Equations of Motion

### Translational Dynamics (body-frame)

Let $F_z = f_1 + f_2 + f_3 + f_4$, where $F_z$ is the total body $+z_b$ thrust. Starting with Newton's second law and a free body diagram, the translational equations of motion are obtained,

$$
\begin{aligned}
\dot{u} &= rv - qw + g\sin\theta
          + \frac{F_z}{m}\big(\cos\phi\,\sin\theta\,\cos\psi + \sin\phi\,\sin\psi\big)\\
\dot{v} &= pw - ru - g\sin\phi\cos\theta
          + \frac{F_z}{m}\big(\cos\phi\,\sin\theta\,\sin\psi - \sin\phi\,\cos\psi\big)\\
\dot{w} &= qu - pv - g\cos\phi\cos\theta
          + \frac{F_z}{m}\big(\cos\phi\,\cos\theta\big)
\end{aligned}
$$

### Rotational Dynamics

From a free body diagram, moments from the individual thrusts are obtained,

$$
\begin{aligned}
M_x &= \sum_i y_i f_i = \frac{l}{\sqrt{2}}(f_1 + f_2 - f_3 - f_4)\\
M_y &= -\sum_i x_i f_i = \frac{l}{\sqrt{2}}(-f_1 + f_2 + f_3 - f_4)\\
M_z &= k_m * (f_1 - f_2 + f_3 - f_4)
\end{aligned}
$$

Starting with Euler's rotational equations of motion, the rigid-body rotational equations of motion are obtained,

$$
\begin{aligned}
\dot{p} &= \frac{I_y - I_z}{I_x}qr + \frac{M_x}{I_x}\\
\dot{q} &= \frac{I_z - I_x}{I_y}pr + \frac{M_y}{I_y}\\
\dot{r} &= \frac{I_x - I_y}{I_z}pq + \frac{M_z}{I_z}
\end{aligned}
$$

### Kinematics (Euler ZYX)

From Direction Cosine Matrix (DCM) kinematics, the time derivative of the yaw, pitch, and roll angles can be calculated based on angular velocity components,

$$
\begin{bmatrix}\dot{\phi} \\\ \dot{\theta} \\\ \dot{\psi}\end{bmatrix} = \begin{bmatrix}
1 & \sin\phi\tan\theta & \cos\phi\tan\theta\\
0 & \cos\phi & -\sin\phi\\
0 & \sin\phi/\cos\theta & \cos\phi/\cos\theta\end{bmatrix}
\begin{bmatrix} p \\\ q \\\ r \end{bmatrix}
$$

---

## Linearization About Hover Operating Point

To linearize the nonlienar equations of motion above, a first-order Taylor series approximation can be applied about an operating point. This operating point is chosen to be during Hover equilibrium conditions, as defined below,

$$
\begin{aligned}
\phi = \theta = \psi = 0 \\
u=v=w=0 \\
p=q=r=0 \\
f_1^\star=f_2^\star=f_3^\star=f_4^\star=\frac{mg}{4}
\end{aligned}
$$

where $f_i^\star$ are the individual rotor thrust magnitudes needed to maintain a hover. Define small thrust perturbations $\Delta f_i = f_i - f_i^\star$ and small perturbations in states, leading to the linearized equations of motion,

$$
\begin{aligned}
\Delta\dot{x} &= \Delta u \\
\Delta\dot{y} &= \Delta v \\
\Delta\dot{z} &= \Delta w \\
\Delta\dot{u} &= g\,\Delta\theta \\
\Delta\dot{v} &= -g\,\Delta\phi \\
\Delta\dot{w} &= \frac{1}{m}\,(\Delta f_1+\Delta f_2+\Delta f_3+\Delta f_4) \\
\Delta\dot{\phi} &= \Delta p \\
\Delta\dot{\theta} &= \Delta q \\
\Delta\dot{\psi} &= \Delta r \\
\Delta\dot{p} &= \frac{1}{I_x}M_x
            = \frac{l}{\sqrt{2}I_x}\(\Delta f_1+\Delta f_2-\Delta f_3-\Delta f_4) \\
\Delta\dot{q} &= \frac{1}{I_y}M_y
            = \frac{l}{\sqrt{2}I_y}\(-\Delta f_1+\Delta f_2+\Delta f_3-\Delta f_4) \\
\Delta\dot{r} &= \frac{k_m}{I_z}(\Delta f_1 - \Delta f_2 + \Delta f_3 - \Delta f_4)
\end{aligned}
$$

Note that the translational velocity components $u$ and $v$ are dependent on the pitch angle ($\theta$) and roll angle ($\phi$), thus there is coupling between these four state variables. With the input vector,

$$
\mathbf{u} =
\begin{bmatrix}\Delta f_1 & \Delta f_2 & \Delta f_3 & \Delta f_4\end{bmatrix}^T
$$

The resulting linearized dynamics capture the small perturbation motion. 

---

## Open Loop Linear State Space Representation

To utilize linear algebra and linear controls techniques, a state space representation can be defined based on the linearized equations of motion,

$$
\dot{\mathbf{x}} = A\mathbf{x} + B\mathbf{u}
$$

The open loop system dynamics matrix (A) and state vector are defined as,

$$
A =
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & g & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & -g & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0     
\end{bmatrix}
,
\mathbf{x} =
\begin{bmatrix}
\Delta x \\
\Delta y \\ 
\Delta z \\ 
\Delta \phi \\ 
\Delta \theta \\ 
\Delta \psi \\ 
\Delta u \\ 
\Delta v \\ 
\Delta w \\ 
\Delta p \\ 
\Delta q \\ 
\Delta r
\end{bmatrix}
$$

The control input dynamics matrix (B) and control inputs vector are defined as,

$$
B =
\begin{bmatrix}
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
\frac{1}{m} & \frac{1}{m} & \frac{1}{m} & \frac{1}{m} \\   
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
-\frac{l}{\sqrt{2}\,I_x} & -\frac{l}{\sqrt{2}\,I_x} & \frac{l}{\sqrt{2}\,I_x} & \frac{l}{\sqrt{2}\,I_x} \\ 
\frac{l}{\sqrt{2}\,I_y} & -\frac{l}{\sqrt{2}\,I_y} & -\frac{l}{\sqrt{2}\,I_y} & \frac{l}{\sqrt{2}\,I_y} \\ 
\frac{k_m}{I_z} & -\frac{k_m}{I_z} & \frac{k_m}{I_z} & -\frac{k_m}{I_z}  
\end{bmatrix}
,
u = 
\begin{bmatrix}
\Delta f_{1} \\
\Delta f_{2} \\ 
\Delta f_{3} \\ 
\Delta f_{4}
\end{bmatrix}
$$

---

## Control Strategy: Linear Quadratic Regulator (LQR)

Based on the linearized equations of motion and state space representation, we have a Multiple Input Mulitple Output (MIMO) system with a few states that are coupled. A great control strategy for this type of system is the LQR. An LQR utilizes an optimal full state feedback gain matrix K to control and stabilize the system, balancing control effort via a control effort weight matrix R: against tracking error via a state error weight matrix: Q. The objective of the LQR minimizes the quadratic cost,

$$
J = \int_0^\infty \big( \mathbf{x}^T Q \mathbf{x} + \mathbf{u}^T R \mathbf{u} \big) dt
$$

- $Q (state error weight matrix) \succeq 0$: penalizes state deviations (e.g. large roll/pitch/yaw angles or position drift)
- $R (control effort weight matrix) \succ 0$: penalizes large control inputs (excessive rotor thrust differentials)

The solution yields an optimal gain matrix,

$$
K = R^{-1} B^T P
$$

where $P$ is the solution to the algebraic Riccati equation,

$$
A^T P + P A - P B R^{-1} B^T P + Q = 0
$$

In the end, the controller law to regulate the system, i.e. decrease state perturbations to zero, about an operating condition is:

$$
\mathbf{u} = -K \mathbf{x}
$$

If we want to track a reference state or set of reference states, we can augment the controller law with the reference state vector,


$$
\mathbf{u} = K (\mathbf{x}_{ref} - \mathbf{x})
$$

Note the LQR is formulated to provide a gain margin from atleast 6dB to infinty and a phase margin of atleast 60° for a perfectly modeled SISO or MIMO (with diagonal weighting matrices) system.

---

## Closed Loop Linear State Space Representation

Substituting the reference state controller law above into the open loop state model, the closed loop state space model is written as,

$$
\dot{\mathbf{x}} = (A - BK) \mathbf{x} + BK\mathbf{x}_{ref}
$$

Note that the gain matrix K can be acquired from a different control strategy such as cascaded PID control or from pole placement. 

Assuming the closed loop system does not have a reference state to track, we can evaluate the stability of the closed loop system when it's perturbed and regulated back to its operating point. This can be done by calculating the eigenvalues of the closed loop system dynamics matrix (A-BK). A stable system will have negative eigenvalue real components. 

---

## Simulation Test Scenario #1: Travel 1 meter forward in X direction relative to inertial frame

With manually tuned LQR weight matrices: Q and R, the closed loop system is put to the test by applying a 1 meter X-axis reference command. The following closed loop system response is shown below,

<img width="1575" height="1172" alt="scenario1_quadcopter_states" src="https://github.com/user-attachments/assets/d88c6117-91d9-4c73-8436-87e4ca37a70c" />

<img width="1577" height="778" alt="scenario1_controller_states" src="https://github.com/user-attachments/assets/18c6a477-4105-4812-9a3c-289a6c3ffd15" />

https://github.com/user-attachments/assets/898d22cc-d957-4b46-8228-042eaf033194

Excellent! The closed loop system is able to track the 1 meter X-axis reference command and converge within ~2 seconds while being under rotor thrust limits.

## Simulation Test Scenario #2: Yaw +60 deg relative to inertial frame

Next, the closed loop system is put to the test by applying a 60 deg yaw reference command. The following closed loop system response is shown below,

<img width="1576" height="1175" alt="scenario2_quadcopter_states" src="https://github.com/user-attachments/assets/53655c43-2559-4996-a414-b446454a5639" />

<img width="1571" height="782" alt="scenario2_controller_states" src="https://github.com/user-attachments/assets/c177c873-1cbc-4592-9033-74dea56fd084" />

https://github.com/user-attachments/assets/14c7a4b3-cb9b-4f58-b7b6-cbeab2ae5b09

Excellent! The closed loop system is able to track the 60 deg yaw reference command and converge within ~4 seconds while being under rotor thrust limits.

## Simulation Test Scenario #3: Track a 1m radius circular path at 1m altitude, while pointing the +X axis towards the center (orbit mode)

Next, the closed loop system is put to the test by tracking dynamic reference commands. The following closed loop system response is shown below,

<img width="1578" height="1179" alt="scenario3_quadcopter_states" src="https://github.com/user-attachments/assets/ce0266be-4ade-4cd5-b3f7-86d6ca861586" />

<img width="1574" height="774" alt="scenario3_controller_states" src="https://github.com/user-attachments/assets/8b0d0494-c727-4c74-8912-3d707663d1c7" />

https://github.com/user-attachments/assets/e0010e52-c231-4f08-8bbe-9c10974e2a3e

For this test scenario, the LQR lags behind the X and Y position commands and has steady error with the yaw command. This serves as a reminder that the Linear Quadratic **Regulator** is meant to regulate states back to the operating point and not meant to track a non-zero external reference, although the LQR does this well for a static reference as seen in the two prior test scenarios above. To resolve the steady state error, a common approach is to add an integrator term to the controller. 

## Control Strategy: Linear Quadratic Integrator (LQI)

To be continued...
