# Quadcopter Project

The objective of this project is to develop a controller to control a 6 Degrees of Freedom (DOF) quadcopter based on a common set of requirements.

---

## Requirements

### System level
* The system shall have the ability to track a desired position within ±0.5 m RSS in horizontal axes and ±0.1 m in altitude under nominal conditions
* The system shall have a pointing accuracy as defined below:
    * Roll/pitch tracking error RMS ≤ 2° (0.0345 rad)
    * Yaw tracking error RMS ≤ 5° (0.0875 rad)

### Mechnical level
* The quadcopter shall have a mass of 1.5 kg
* The quadcopter shall have a moments of inertia of: $I_{xx}$ = 0.03 $kgm^2$, $I_{yy}$ = 0.03 $kgm^2$, $I_{zz}$ = 0.05 $kgm^2$
* The quadcopter shall have rotor arm lengths of 0.225 m each

### Actuator level
* The quadcopter shall have the rotors in a cross-configuration, with the first rotor in between the body X and Y axes
* The quadcopter total lift shall have a 2:1 lift-to-weight ratio, with each rotor having the same lift capability

### Controller level
* Gain and phase margins shall be ≥6 dB and ≥45°, respectively
* The controller shall handle end-to-end latency (dead time) of at least 20 ms
* The control algorithm update rate shall run at least at 50 Hz
* The controller shall not demand lift or torque exceeding 100% of rotor limits during nominal operation.

## Overview

A quadcopter is a 6-DOF rigid body with four independent rotors. Its dynamics can be split into:

- Translational dynamics (position and velocity in 3D space).
- Rotational dynamics (attitude and angular rates).
- Control inputs (lifts generated by each rotor).

We model the quadcopter system parameters relative the body frame (attached to the quadcopter) and model its motion relative to an inertial frame (Earth-fixed, North-East-Down). Note the body Z-axis is pointed downwards towards the ground.

<img width="678" height="519" alt="quadcopter_body_frame" src="https://github.com/user-attachments/assets/7e5b6762-ec1f-4a5e-b721-eb3c31cc4c0b" />

- Rotor 1: $(x_1,y_1) = \big(\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$  (between +X and +Y)  
- Rotor 2: $(x_2,y_2) = \big(-\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$ (between −X and +Y)  
- Rotor 3: $(x_3,y_3) = \big(-\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between −X and −Y)  
- Rotor 4: $(x_4,y_4) = \big(\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between +X and −Y)

The arm length is given as $l$.

---

## Assumptions

To break down and simplify the problem, let's define some assumptions,

* The quadcopter system is time invariant (i.e. no change in mass properties or rotor lift capabilities)
* The quadcopter is a rigid body (i.e. no structural flexible modes)
* The quadcopter states are fully controllable and observable (note this can be assessed by forming the controllability and observability Gramian matrices)
* Each rotor have a similar thrust coefficient ($C_{T}$)of 2.0E-5 $\frac{N}{(\frac{rad}{s})^2}$ and a propeller drag ($C_{D}$) coefficient of 8.0E-7 $\frac{Nm}{(\frac{rad}{s})^2}$. This can be later tuned based on actual hardware characteristics.

## State and System Parameter Definition

We define the state vector:

$$
\mathbf{x} =
\begin{bmatrix}
x & y & z & u & v & w & \phi & \theta & \psi & p & q & r
\end{bmatrix}^T
$$

where:
- $x,y,z$: position vector components, inertial frame
- $u,v,w$: translational velocity components, body-frame
- $\phi, \theta, \psi$: Euler roll pitch, yaw angles
- $p,q,r$: rotational velocity components, body-frame

Mass properties of the quadcopter are: mass $m$ and principal moments of inertia $I_x,I_y,I_z$. Gravitational acceleration constant is represented as: $g$.

---

## Control Inputs
Note for a realistic quadcopter, the commanded rotor forces are achieved by translating the commanded rotor forces to commanded rotor spin speeds, and sending those commands to Electronic Speed Controllers (ESCs). The mapping from rotor lift to rotor spin speed is given by the following simplified expression,

$$
f_i = C_{T} \omega_i^2 \text{, i} \in \{1, 2, 3, 4\}
$$

where $C_{T}$ is the thrust coefficient. Each rotor produces lift $f_i$ along the body $+z_b$ axis (opposing gravity when pitched/rolled to tilt the lift vector), and scales with the rotor spin speed squared that's adjusted by the thrust coefficient. The reaction torque onto the quadcopter along the vertical Z axis (about $z_b$) is calculated as a sum of the rotor torques, which is a function of the rotor propeller drag force as shown below,

$$
\tau_z = C_{D} (\omega_1^2 - \omega_2^2 + \omega_3^2 - \omega_4^2)
$$

 where $C_{D}$ is the rotor's propeller drag coefficient. The signs of the rotor lift forces are intentional with two rotors spinning clockwise and the other two rotors spinning counter-clockwise, this allows the rotors to synchronously spin up without torquing the quadcopter. 

---

## Nonlinear Equations of Motion

### Translational Dynamics

Let $F_z = f_1 + f_2 + f_3 + f_4$, where $F_z$ is the total body lift force from the rotors that acts along the $+z_b$ axis. Starting with Newton's second law and a free body diagram, the translational equations of motion relative to the NED inertial frame are obtained,

$$
\begin{aligned}
\dot{u} &= - \frac{F_z}{m}\big(\cos\phi\ \sin\theta\ \cos\psi + \sin\phi\ \sin\psi\big)\\
\dot{v} &= - \frac{F_z}{m}\big(\cos\phi\ \sin\theta\ \sin\psi - \sin\phi\ \cos\psi\big)\\
\dot{w} &= g - \frac{F_z}{m}\big(\cos\phi\ \cos\theta\big)
\end{aligned}
$$

where the total body lift force varies depending on the attitude of the quadcopter. Note that the total rotor lift force acts in the opposite direction of the body frame. 

### Rotational Dynamics

From a free body diagram, moments from the individual rotor lift forces and drag torques are obtained,

$$
\begin{aligned}
M_x &= \sum_i y_i f_i = \frac{l}{\sqrt{2}}(f_1 + f_2 - f_3 - f_4) = \frac{l \cdot C_{L} }{\sqrt{2}}\(\omega_1^2 + \omega_2^2 - \omega_3^2 - \omega_4^2)\\
M_y &= -\sum_i x_i f_i = \frac{l}{\sqrt{2}}(-f_1 + f_2 + f_3 - f_4) = \frac{l \cdot C_{L}}{\sqrt{2}}\(-\omega_1^2 + \omega_2^2 + \omega_3^2 - \omega_4^2) \\
M_z & = C_{D} (\omega_1^2 - \omega_2^2 + \omega_3^2 - \omega_4^2)
\end{aligned}
$$

where $l$ is the arm length from the quadcopter CG to each rotor. Starting with Euler's rotational equations of motion, the rigid-body rotational equations of motion are obtained,

$$
\begin{aligned}
\dot{p} &= \frac{I_y - I_z}{I_x}qr + \frac{M_x}{I_x}\\
\dot{q} &= \frac{I_z - I_x}{I_y}pr + \frac{M_y}{I_y}\\
\dot{r} &= \frac{I_x - I_y}{I_z}pq + \frac{M_z}{I_z}
\end{aligned}
$$

### Kinematics (Euler ZYX)

From Direction Cosine Matrix (DCM) kinematics, the time derivative of the yaw, pitch, and roll angles can be calculated based on angular velocity components,

$$
\begin{bmatrix}\dot{\phi} \\\ \dot{\theta} \\\ \dot{\psi}\end{bmatrix} = \begin{bmatrix}
1 & \sin\phi\tan\theta & \cos\phi\tan\theta\\
0 & \cos\phi & -\sin\phi\\
0 & \sin\phi/\cos\theta & \cos\phi/\cos\theta\end{bmatrix}
\begin{bmatrix} p \\\ q \\\ r \end{bmatrix}
$$

---

## Linearization About Hover Operating Point

To linearize the nonlienar equations of motion above, a first-order Taylor series approximation can be applied about an operating point. This operating point is chosen to be during Hover equilibrium conditions, as defined below,

$$
\begin{aligned}
\phi = \theta = \psi = 0 \\
u=v=w=0 \\
p=q=r=0 \\
f_{\text{trim}} = mg \\
\omega_{1,\text{trim}}^2=\omega_{2,\text{trim}}^2=\omega_{3,\text{trim}}^2=\omega_{4,\text{trim}}^2= \frac{1}{C_{L}} (\frac{f_{\text{trim}}}{4})
\end{aligned}
$$

where $\omega_{i,\text{trim}}^2$ are the individual rotor squared spin speeds needed to maintain a hover. Define small squared spin speed perturbations $\Delta \omega_i = \omega_i - \omega_{i,\text{trim}}$ and small perturbations in states, leading to the linearized equations of motion,

$$
\begin{aligned}
\Delta\dot{x} &= \Delta u \\
\Delta\dot{y} &= \Delta v \\
\Delta\dot{z} &= \Delta w \\
\Delta\dot{u} &= g \Delta \theta \\
\Delta\dot{v} &= -g \Delta \phi \\
\Delta\dot{w} &= - \frac{C_{L}}{m}(\Delta \omega_1^2 + \Delta \omega_2^2 + \Delta \omega_3^2 + \Delta \omega_4^2) \\
\Delta\dot{\phi} &= \Delta p \\
\Delta\dot{\theta} &= \Delta q \\
\Delta\dot{\psi} &= \Delta r \\
\Delta\dot{p} &= \frac{1}{I_x}M_x
            = \frac{l \cdot C_{L} }{\sqrt{2}I_x}\(\Delta \omega_1^2 + \Delta \omega_2^2 - \Delta \omega_3^2 - \Delta \omega_4^2) \\
\Delta\dot{q} &= \frac{1}{I_y}M_y
            = \frac{l \cdot C_{L}}{\sqrt{2}I_y}\(-\Delta \omega_1^2 + \Delta \omega_2^2 + \Delta \omega_3^2 - \Delta \omega_4^2) \\
\Delta\dot{r} &= \frac{C_{D}}{I_z}(\Delta \omega_1^2 - \Delta \omega_2^2 + \Delta \omega_3^2 - \Delta \omega_4^2)
\end{aligned}
$$

Note that the translational velocity components $u$ and $v$ are dependent on the pitch angle ($\theta$) and roll angle ($\phi$), thus there is coupling between these four state variables. With the input vector,

$$
\mathbf{u} =
\begin{bmatrix}\Delta \omega_1^2 & \Delta \omega_2^2 & \Delta \omega_3^2 & \Delta \omega_4^2 \end{bmatrix}^T
$$

The resulting linearized dynamics capture the small perturbation motion. 

---

## Open Loop Linear State Space Representation

To utilize linear algebra and linear controls techniques, a state space representation can be defined based on the linearized equations of motion,

$$
\dot{\mathbf{x}} = A\mathbf{x} + B\mathbf{u}
$$

The open loop system dynamics matrix (A) and state vector are defined as,

$$
A =
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & g & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & -g & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0     
\end{bmatrix}
,
\mathbf{x} =
\begin{bmatrix}
\Delta x \\
\Delta y \\ 
\Delta z \\ 
\Delta u \\ 
\Delta v \\ 
\Delta w \\ 
\Delta \phi \\ 
\Delta \theta \\ 
\Delta \psi \\ 
\Delta p \\ 
\Delta q \\ 
\Delta r
\end{bmatrix}
$$

The control input dynamics matrix (B) and control inputs vector are defined as,

$$
B =
\begin{bmatrix}
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
-\frac{C_{L}}{m} & -\frac{C_{L}}{m} & -\frac{C_{L}}{m} & -\frac{C_{L}}{m} \\   
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
-\frac{l \cdot C_{L} }{\sqrt{2}\,I_x} & -\frac{l \cdot C_{L} }{\sqrt{2}\,I_x} & \frac{l \cdot C_{L} }{\sqrt{2}\,I_x} & \frac{l \cdot C_{L} }{\sqrt{2}\,I_x} \\ 
\frac{l \cdot C_{L} }{\sqrt{2}\,I_y} & -\frac{l \cdot C_{L} }{\sqrt{2}\,I_y} & -\frac{l \cdot C_{L} }{\sqrt{2}\,I_y} & \frac{l \cdot C_{L} }{\sqrt{2}\,I_y} \\ 
\frac{C_{D}}{I_z} & -\frac{C_{D}}{I_z} & \frac{C_{D}}{I_z} & -\frac{C_{D}}{I_z}  
\end{bmatrix}
,
u = 
\begin{bmatrix}
\Delta \omega_{1}^2 \\
\Delta \omega_{2}^2 \\ 
\Delta \omega_{3}^2 \\ 
\Delta \omega_{4}^2
\end{bmatrix}
$$

---

## Control Strategy: Linear Quadratic Regulator (LQR)

Based on the linearized equations of motion and state space representation, we have a Multiple Input Mulitple Output (MIMO) system with a few states that are coupled. A great control strategy for this type of system is the LQR. An LQR utilizes an optimal full state feedback gain matrix K to control and stabilize the system, balancing control effort via a control effort weight matrix R: against tracking error via a state error weight matrix: Q. The objective of the LQR minimizes the quadratic cost,

$$
J = \int_0^\infty \big( \mathbf{x}^T Q \mathbf{x} + \mathbf{u}^T R \mathbf{u} \big) dt
$$

- $\text{state error weight matrix}: Q \succeq 0$: penalizes state deviations (e.g. large roll/pitch/yaw angles or position drift)
- $\text{control effort weight matrix}: R \succ 0$: penalizes large control inputs (excessive rotor lift differentials)

The solution yields an optimal gain matrix,

$$
K = R^{-1} B^T P
$$

where $P$ is the solution to the algebraic Riccati equation,

$$
A^T P + P A - P B R^{-1} B^T P + Q = 0
$$

In the end, the controller law to regulate the system, i.e. decrease state perturbations to zero, about an operating condition is:

$$
\mathbf{u} = -K \mathbf{x}
$$

If we want to track a reference state or set of reference states, we can augment the controller law with the reference state vector,


$$
\mathbf{u} = K (\mathbf{x}_{ref} - \mathbf{x})
$$

Note the LQR is formulated to provide a gain margin from atleast 6dB to infinty and a phase margin of atleast 60° for a perfectly modeled SISO or MIMO (with diagonal weighting matrices) system.

---

## Closed Loop Linear State Space Representation

Substituting the reference state controller law above into the open loop state model, the closed loop state space model is written as,

$$
\dot{\mathbf{x}} = (A - BK) \mathbf{x} + BK\mathbf{x}_{ref}
$$

Note that the gain matrix K can be acquired from a different control strategy such as cascaded PID control or from pole placement. 

Assuming the closed loop system does not have a reference state to track, we can evaluate the stability of the closed loop system when it's perturbed and regulated back to its operating point. This can be done by calculating the eigenvalues of the closed loop system dynamics matrix (A-BK). A stable system will have negative eigenvalue real components. 

---

## Simulation Test Scenario #1: Travel 1 meter forward in X direction relative to inertial frame

With manually tuned LQR weight matrices: Q and R, the closed loop system is put to the test by applying a 1 meter X-axis reference command. The following closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario1_quadcopter_states" src="https://github.com/user-attachments/assets/e06f580c-147d-41ea-b9c8-fa0833e900ad" />  |  <img width="1600" height="1200" alt="scenario1_quadcopter_states_nonlinear" src="https://github.com/user-attachments/assets/2eb5b0ad-cf6b-4d50-9730-1b2a2160976d" />
<img width="1600" height="800" alt="scenario1_controller_states" src="https://github.com/user-attachments/assets/9e110761-93d1-4b63-bfc5-f6e715b3fd07" />  |   <img width="1600" height="800" alt="scenario1_controller_states_nonlinear" src="https://github.com/user-attachments/assets/f3dd2f3b-19e9-417e-aa6b-d00df8b94bbe" />

https://github.com/user-attachments/assets/390ec5a9-a44d-4b16-bb12-bed08b36fcdc

Excellent! The closed loop system is able to track the 1 meter X-axis reference command and converge within ~2 seconds while being under rotor lift limits.

## Simulation Test Scenario #2: Yaw +45 deg relative to inertial frame

Next, the closed loop system is put to the test by applying a 45 deg yaw reference command. The following closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario2_quadcopter_states" src="https://github.com/user-attachments/assets/5119b183-a2e8-4f1a-8c9d-53776afd7210" />  |   <img width="1600" height="1200" alt="scenario2_quadcopter_states_nonlinear" src="https://github.com/user-attachments/assets/9b51d916-da13-4af9-bec5-f560e0ae40ae" />
<img width="1600" height="800" alt="scenario2_controller_states" src="https://github.com/user-attachments/assets/c7cadb3c-ad0a-4424-ab9d-9501f974ab7a" />  |   <img width="1600" height="800" alt="scenario2_controller_states_nonlinear" src="https://github.com/user-attachments/assets/188f6bb6-2bfd-41f5-93aa-c75f75a00194" />

https://github.com/user-attachments/assets/a4b0284f-8c47-4059-b57e-491f0984111d

Excellent! The closed loop system is able to track the 60 deg yaw reference command and converge within ~4 seconds while being under rotor lift limits.

## Simulation Test Scenario #3: Track a 1m radius CCW circular path at 1m altitude, while pointing the +X axis towards the center (orbit mode)

Next, the closed loop system is put to the test by tracking dynamic reference commands. Given our NED inertial frame, the equations for a circular counter-clockwise (CCW) trajectory over time are given below,

$$
\begin{aligned}
x_{desired}(t) = Rcos(2\pi\frac{t}{T}) \\
y_{desired}(t) = -Rsin(2\pi\frac{t}{T}) \\
\end{aligned}
$$

where R is the circle radius and T is the time period for one full circular revolution. A 30 second time period was chosen for this test scenario. The feedback controller was modified to apply yaw control when the quadcopter is at least 0.5m away from the center of the circle to avoid singularity in the yaw error calculation. The following closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario3_quadcopter_states" src="https://github.com/user-attachments/assets/6ad94d85-05a1-4c7a-a216-d11192f2a10e" />    |  <img width="1600" height="1200" alt="scenario3_quadcopter_states_nonlinear" src="https://github.com/user-attachments/assets/768e3241-9f04-4d2e-8d57-4edeed5c377d" />
<img width="1600" height="800" alt="scenario3_controller_states" src="https://github.com/user-attachments/assets/5e82dc2f-e403-44e3-8c1f-0e0827c6b0ea" />     |  <img width="1600" height="800" alt="scenario3_controller_states_nonlinear" src="https://github.com/user-attachments/assets/a16a2e52-967c-454a-b5ee-5b93509acb2d" />

https://github.com/user-attachments/assets/4e5d89ba-c8c0-40b0-b38a-73e5837c876e

For this test scenario, the LQR lags behind the X and Y position commands and has steady error with the yaw command. This serves as a reminder that the Linear Quadratic **Regulator** is meant to regulate states back to the operating point and is not meant to track a dynamic reference, the LQR tracks really well for a static reference as seen in the two prior test scenarios above. To resolve the steady state yaw angle error, a common approach is to add an integrator term to the controller. 

##  Simulation Test Scenario #3 Repeat: New Control Strategy, the Linear Quadratic Integrator (LQI)

To add an integrator to the controller, we can integrate the yaw angle error by numerically summing up the yaw angle error, scaled by the time step, multiply the integrated error by a gain, and then add the final integrator result to our controller as analytically shown below,

$$
\mathbf{u} = -K \mathbf{x} - K_{i}\int_{0}^{t}(\mathbf{r} - \mathbf{x}\)dt
$$

Whenever adding an integrator term to a controller, it's good practice to apply a +/- clamping limit and optionally an activation region for when we want the integrator to kick in (e.g. if yaw angle error is < 5 deg, then start integrating the error). Both of these features are to avoid integrator windup and reduce overshoot from the "momentum" that the integrator has built up. The following closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario3_quadcopter_states_yaw_integrator" src="https://github.com/user-attachments/assets/17c2e70e-4fc8-4b8a-baa2-fff7ce0c82b0" />    |  <img width="1600" height="1200" alt="scenario3_quadcopter_states_nonlinear" src="https://github.com/user-attachments/assets/1e23540d-77fd-410c-8920-3369d84c2f81" />
<img width="1600" height="800" alt="scenario3_controller_states_yaw_integrator" src="https://github.com/user-attachments/assets/f264c58e-66aa-49ee-babf-00134f0488f9" />    |  <img width="1600" height="800" alt="scenario3_controller_states_yaw_integrator_nonlinear" src="https://github.com/user-attachments/assets/268180a4-0592-41fd-9cab-7225701d68ed" />

https://github.com/user-attachments/assets/c3c0ce02-4ea2-42fa-9108-76abcce2be55

Excellent! The integrator contribution improved the controller's ability to point towards the center of the circle and reduce the steady state yaw angle error to near zero. To improve the closed loop system's lag response with tracking the X and Y position commands, we can also include X and Y rate commands to the mix since we know analytically how the circular trajectory changes over time.

##  Simulation Test Scenario #3 Repeat: Inclusion of Reference Rate Command

Given the equations for a circular counter-clockwise (CCW) trajectory above, the desired X and Y translation rate and yaw rate commands to apply are given below,

$$
\begin{aligned}
\dot{x}_{desired}(t) = -\frac{R2\pi}{T}sin(2\pi\frac{t}{T}) \\
\dot{y}_{desired}(t) = -\frac{R2\pi}{T}cos(2\pi\frac{t}{T}) \\
\dot{\psi}_{desired}(t) = -\frac{2\pi}{T}   \\
\text{(negative for CCW rotation, based on NED frame)}
\end{aligned}
$$

where R is the circle radius and T is the time period for one full circular revolution. Adding these rate commands to the reference state vector profile, the closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario3_quadcopter_states_yaw_integrator_ _vel_reference" src="https://github.com/user-attachments/assets/0c6f820e-b576-4c65-9ebd-680d1a37baa0" />    |  <img width="1600" height="1200" alt="scenario3_quadcopter_states_yaw_integrator_ _vel_reference_nonlinear" src="https://github.com/user-attachments/assets/8ba55898-a064-4a95-ae8c-d4dfb7b36945" />
<img width="1600" height="800" alt="scenario3_controller_states_yaw_integrator_ _vel_reference" src="https://github.com/user-attachments/assets/8d119677-c491-4fe3-8c7c-6d5113ea6788" />    |  <img width="1600" height="800" alt="scenario3_controller_states_yaw_integrator_ _vel_reference_nonlinear" src="https://github.com/user-attachments/assets/d67cbdc6-bed5-4a90-af4a-7e78d16e7e9c" />

https://github.com/user-attachments/assets/b6696e7d-ccc5-43c1-9500-455364e5de2d

Excellent! The circular reference trajectory rate commands improved the controller's ability to track the trajectory and mitigate the lagged response. It's interesting that the controller tracks slightly outside of the circular trajectory, but per requirements, this is within bounds! Let's put the controller through another test with a dynamic z position reference.

## Simulation Test Scenario #4: Track a 1m radius CCW circular path with the altitude ramping up and down to 1m, while pointing the +X axis towards the center (spiral mode)

Increasing the initial desired altitude to 2m and tracking a 1m downwards spiral reference trajectory away from the origin, the closed loop system response is shown below,

Linearized EOM            |  Nonlinear EOM
:-------------------------:|:-------------------------:
<img width="1600" height="1200" alt="scenario4_quadcopter_states_yaw_integrator_ _vel_reference" src="https://github.com/user-attachments/assets/225e2850-419d-4f47-85dd-3a2c2dd93301" />    | <img width="1600" height="1200" alt="scenario4_quadcopter_states_yaw_integrator_ _vel_reference_nonlinear" src="https://github.com/user-attachments/assets/24d00ccb-16bc-4308-93fa-6fdd6669c1ce" />
<img width="1600" height="800" alt="scenario4_controller_states_yaw_integrator_ _vel_reference" src="https://github.com/user-attachments/assets/924d33bc-a532-4bef-ac3f-ca368a76b011" />    |  <img width="1600" height="800" alt="scenario4_controller_states_yaw_integrator_ _vel_reference_nonlinear" src="https://github.com/user-attachments/assets/2731afc1-645c-4dd8-90aa-760bb016fd7b" />

https://github.com/user-attachments/assets/ae397918-31bd-4ea4-8be1-25d1d0617ea5

Excellent, the LQI controller is keeping up quite well! 

## Adding in Rotor Speed Dynamics
To be continued... 

## Adding in Sensors and State Estimation
To be continued... 

## Adding in Dead Time
To be continued... 

## Closed Loop Stability Analysis

To be continued... 
