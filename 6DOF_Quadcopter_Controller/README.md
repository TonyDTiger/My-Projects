# Quadcopter Project

The objective of this project is to develop a controller to control a 6 Degrees of Freedom (DOF) quadcopter based on a common set of requirements.

---

## Requirements

### System level
* The system shall have the ability to track a desired position within ±0.5 m in horizontal axes and ±0.25 m in altitude under nominal conditions
* The system shall have a pointing accuracy as defined below:
    * Roll/pitch tracking error RMS ≤ 2° (0.0345 rad)
    * Yaw tracking error RMS ≤ 5° (0.0875 rad)

### Mechnical level
* The quadcopter shall have a mass of 1.5 kg
* The quadcopter shall have a moments of inertia of: $I_{xx}$ = 0.03 $kgm^2$, $I_{yy}$ = 0.03 $kgm^2$, $I_{zz}$ = 0.05 $kgm^2$
* The quadcopter shall have rotor arm lengths of 0.225 m each

### Actuator level
* The quadcopter shall have the rotors in a cross-configuration, with the first rotor in between the body X and Y axes
* The quadcopter total thrust shall have a 2:1 thrust-to-weight ratio, with each rotor having the same thrust capability
* The rotors shall have a thrust coefficient ($C_{L}$)of 2.3E-5 $\frac{N}{(\frac{rad}{s})^2}$ and a moment drag ($C_{D}$) coefficient of 7.8E-7 $\frac{Nm}{(\frac{rad}{s})^2}$

### Controller level
* Gain and phase margins shall be ≥6 dB and ≥45°, respectively
* The control algorithm shall run at a 50 Hz update rate
* The controller shall handle sensor-to-actuator latency ≤ 20 ms (end-to-end)
* The controller shall not demand thrust or torque exceeding 100% of rotor limits during nominal operation.

## Overview

A quadcopter is a 6-DOF rigid body with four independent rotors. Its dynamics can be split into:

- Translational dynamics (position and velocity in 3D space).
- Rotational dynamics (attitude and angular rates).
- Control inputs (thrusts generated by each rotor).

We model the quadcopter system parameters relative the body frame (attached to the quadcopter) and model its motion relative to an inertial frame (Earth-fixed, North-East-Down).

<img width="678" height="519" alt="quadcopter_body_frame" src="https://github.com/user-attachments/assets/7e5b6762-ec1f-4a5e-b721-eb3c31cc4c0b" />

- Rotor 1: $(x_1,y_1) = \big(\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$  (between +X and +Y)  
- Rotor 2: $(x_2,y_2) = \big(-\tfrac{l}{\sqrt{2}}, \tfrac{l}{\sqrt{2}}\big)$ (between −X and +Y)  
- Rotor 3: $(x_3,y_3) = \big(-\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between −X and −Y)  
- Rotor 4: $(x_4,y_4) = \big(\tfrac{l}{\sqrt{2}}, -\tfrac{l}{\sqrt{2}}\big)$ (between +X and −Y)

The arm length is given as $l$.

---

## Assumptions

To break down and simplify the problem, let's define some assumptions,

* The quadcopter system is time invariant (i.e. no change in mass properties or rotor thrust capabilities)
* The quadcopter is a rigid body (i.e. no structural flexible modes)
* The quadcopter states are fully controllable and observable (note this can be assessed by forming the controllability and observability Gramian matrices)
* Rotor forces and torques are immediately actuated

## State and System Parameter Definition

We define the state vector:

$$
\mathbf{x} =
\begin{bmatrix}
x & y & z & u & v & w & \phi & \theta & \psi & p & q & r
\end{bmatrix}^T
$$

where:
- $x,y,z$: position vector components, inertial frame
- $u,v,w$: translational velocity components, body-frame
- $\phi, \theta, \psi$: Euler roll pitch, yaw angles
- $p,q,r$: rotational velocity components, body-frame

Mass properties of the quadcopter are: mass $m$ and principal moments of inertia $I_x,I_y,I_z$. Gravitational acceleration constant is represented as: $g$.

---

## Control Inputs

- Each rotor produces thrust $f_i$ along the body $+z_b$ axis (opposing gravity when pitched/rolled to tilt the thrust vector).
- Arm length from the CG to each rotor is $l$.
- The reaction torque onto the quadcopter along the vertical Z axis (about $z_b$) is calculated as a sum of the rotor torques, which can be represented as functions of the rotor lift and drag forces (where $k_{m}$ is a constant ratio of the rotor's lift and drag coefficients) are calculated as shown below,

$$
\tau_z = k_{m} (f_1 - f_2 + f_3 - f_4)
$$

Note for a realistic quadcopter, the commanded rotor forces are achieved by translating the commanded rotor forces to commanded rotor spin speeds, and sending those commands to Electronic Speed Controllers (ESCs). This is future work to complete, for now let's press on with commanding rotor forces.

---

## Nonlinear Equations of Motion

### Translational Dynamics (body-frame)

Let $F_z = f_1 + f_2 + f_3 + f_4$, where $F_z$ is the total body $+z_b$ thrust. Starting with Newton's second law and a free body diagram, the translational equations of motion are obtained,

$$
\begin{aligned}
\dot{u} &= rv - qw + g\sin\theta
          + \frac{F_z}{m}\big(\cos\phi\,\sin\theta\,\cos\psi + \sin\phi\,\sin\psi\big)\\
\dot{v} &= pw - ru - g\sin\phi\cos\theta
          + \frac{F_z}{m}\big(\cos\phi\,\sin\theta\,\sin\psi - \sin\phi\,\cos\psi\big)\\
\dot{w} &= qu - pv - g\cos\phi\cos\theta
          + \frac{F_z}{m}\big(\cos\phi\,\cos\theta\big)
\end{aligned}
$$

### Rotational Dynamics

From a free body diagram, moments from the individual thrusts are obtained,

$$
\begin{aligned}
M_x &= \sum_i y_i f_i = \frac{l}{\sqrt{2}}(f_1 + f_2 - f_3 - f_4)\\
M_y &= -\sum_i x_i f_i = \frac{l}{\sqrt{2}}(-f_1 + f_2 + f_3 - f_4)\\
M_z &= k_m * (f_1 - f_2 + f_3 - f_4)
\end{aligned}
$$

Starting with Euler's rotational equations of motion, the rigid-body rotational equations of motion are obtained,

$$
\begin{aligned}
\dot{p} &= \frac{I_y - I_z}{I_x}qr + \frac{M_x}{I_x}\\
\dot{q} &= \frac{I_z - I_x}{I_y}pr + \frac{M_y}{I_y}\\
\dot{r} &= \frac{I_x - I_y}{I_z}pq + \frac{M_z}{I_z}
\end{aligned}
$$

### Kinematics (Euler ZYX)

From Direction Cosine Matrix (DCM) kinematics, the time derivative of the yaw, pitch, and roll angles can be calculated based on angular velocity components,

$$
\begin{bmatrix}\dot{\phi} \\\ \dot{\theta} \\\ \dot{\psi}\end{bmatrix} = \begin{bmatrix}
1 & \sin\phi\tan\theta & \cos\phi\tan\theta\\
0 & \cos\phi & -\sin\phi\\
0 & \sin\phi/\cos\theta & \cos\phi/\cos\theta\end{bmatrix}
\begin{bmatrix} p \\\ q \\\ r \end{bmatrix}
$$

---

## Linearization About Hover Operating Point

To linearize the nonlienar equations of motion above, a first-order Taylor series approximation can be applied about an operating point. This operating point is chosen to be during Hover equilibrium conditions, as defined below,

$$
\begin{aligned}
\phi = \theta = \psi = 0 \\
u=v=w=0 \\
p=q=r=0 \\
f_1^\star=f_2^\star=f_3^\star=f_4^\star=\frac{mg}{4}
\end{aligned}
$$

where $f_i^\star$ are the individual rotor thrust magnitudes needed to maintain a hover. Define small thrust perturbations $\Delta f_i = f_i - f_i^\star$ and small perturbations in states, leading to the linearized equations of motion,

$$
\begin{aligned}
\Delta\dot{x} &= \Delta u \\
\Delta\dot{y} &= \Delta v \\
\Delta\dot{z} &= \Delta w \\
\Delta\dot{u} &= g\,\Delta\theta \\
\Delta\dot{v} &= -g\,\Delta\phi \\
\Delta\dot{w} &= \frac{1}{m}\,(\Delta f_1+\Delta f_2+\Delta f_3+\Delta f_4) \\
\Delta\dot{\phi} &= \Delta p \\
\Delta\dot{\theta} &= \Delta q \\
\Delta\dot{\psi} &= \Delta r \\
\Delta\dot{p} &= \frac{1}{I_x}M_x
            = \frac{l}{\sqrt{2}I_x}\(\Delta f_1+\Delta f_2-\Delta f_3-\Delta f_4) \\
\Delta\dot{q} &= \frac{1}{I_y}M_y
            = \frac{l}{\sqrt{2}I_y}\(-\Delta f_1+\Delta f_2+\Delta f_3-\Delta f_4) \\
\Delta\dot{r} &= \frac{k_m}{I_z}(\Delta f_1 - \Delta f_2 + \Delta f_3 - \Delta f_4)
\end{aligned}
$$

Note that the translational velocity components $u$ and $v$ are dependent on the pitch angle ($\theta$) and roll angle ($\phi$), thus there is coupling between these four state variables. With the input vector,

$$
\mathbf{u} =
\begin{bmatrix}\Delta f_1 & \Delta f_2 & \Delta f_3 & \Delta f_4\end{bmatrix}^T
$$

The resulting linearized dynamics capture the small perturbation motion. 

---

## Open Loop Linear State Space Representation

To utilize linear algebra and linear controls techniques, a state space representation can be defined based on the linearized equations of motion,

$$
\dot{\mathbf{x}} = A\mathbf{x} + B\mathbf{u}
$$

The open loop system dynamics matrix (A) and state vector are defined as,

$$
A =
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & g & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & -g & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\   
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0     
\end{bmatrix}
,
\mathbf{x} =
\begin{bmatrix}
\Delta x \\
\Delta y \\ 
\Delta z \\ 
\Delta \phi \\ 
\Delta \theta \\ 
\Delta \psi \\ 
\Delta u \\ 
\Delta v \\ 
\Delta w \\ 
\Delta p \\ 
\Delta q \\ 
\Delta r
\end{bmatrix}
$$

The control input dynamics matrix (B) and control inputs vector are defined as,

$$
B =
\begin{bmatrix}
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
\frac{1}{m} & \frac{1}{m} & \frac{1}{m} & \frac{1}{m} \\   
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
0 & 0 & 0 & 0 \\  
-\frac{l}{\sqrt{2}\,I_x} & -\frac{l}{\sqrt{2}\,I_x} & \frac{l}{\sqrt{2}\,I_x} & \frac{l}{\sqrt{2}\,I_x} \\ 
\frac{l}{\sqrt{2}\,I_y} & -\frac{l}{\sqrt{2}\,I_y} & -\frac{l}{\sqrt{2}\,I_y} & \frac{l}{\sqrt{2}\,I_y} \\ 
\frac{k_m}{I_z} & -\frac{k_m}{I_z} & \frac{k_m}{I_z} & -\frac{k_m}{I_z}  
\end{bmatrix}
,
u = 
\begin{bmatrix}
\Delta f_{1} \\
\Delta f_{2} \\ 
\Delta f_{3} \\ 
\Delta f_{4}
\end{bmatrix}
$$

---

## Control Strategy: Linear Quadratic Regulator (LQR)

Based on the linearized equations of motion and state space representation, we have a Multiple Input Mulitple Output (MIMO) system with a few states that are coupled. A great control strategy for this type of system is the LQR. An LQR utilizes an optimal full state feedback gain matrix K to control and stabilize the system, balancing control effort via a control effort weight matrix R: against tracking error via a state error weight matrix: Q. The objective of the LQR minimizes the quadratic cost,

$$
J = \int_0^\infty \big( \mathbf{x}^T Q \mathbf{x} + \mathbf{u}^T R \mathbf{u} \big) dt
$$

- $Q (state error weight matrix) \succeq 0$: penalizes state deviations (e.g. large roll/pitch/yaw angles or position drift)
- $R (control effort weight matrix) \succ 0$: penalizes large control inputs (excessive rotor thrust differentials)

The solution yields an optimal gain matrix,

$$
K = R^{-1} B^T P
$$

where $P$ is the solution to the algebraic Riccati equation,

$$
A^T P + P A - P B R^{-1} B^T P + Q = 0
$$

In the end, the controller law to regulate the system, i.e. decrease state perturbations to zero, about an operating condition is:

$$
\mathbf{u} = -K \mathbf{x}
$$

If we want to track a reference state or set of reference states, we can augment the controller law with the reference state vector,


$$
\mathbf{u} = K (\mathbf{x}_{ref} - \mathbf{x})
$$

Note the LQR is formulated to provide a gain margin from atleast 6dB to infinty and a phase margin of atleast 60° for a perfectly modeled SISO or MIMO (with diagonal weighting matrices) system.

---

## Closed Loop Linear State Space Representation

Substituting the reference state controller law above into the open loop state model, the closed loop state space model is written as,

$$
\dot{\mathbf{x}} = (A - BK) \mathbf{x} + BK\mathbf{x}_{ref}
$$

Note that the gain matrix K can be acquired from a different control strategy such as cascaded PID control or from pole placement. 

Assuming the closed loop system does not have a reference state to track, we can evaluate the stability of the closed loop system when it's perturbed and regulated back to its operating point. This can be done by calculating the eigenvalues of the closed loop system dynamics matrix (A-BK). A stable system will have negative eigenvalue real components. 

---

## Simulation Test Scenario #1: Travel 1 meter forward in X direction relative to inertial frame

With manually tuned LQR weight matrices: Q and R, the closed loop system is put to the test by applying a 1 meter X-axis reference command. The following closed loop system response is shown below,

<img width="1575" height="1172" alt="scenario1_quadcopter_states" src="https://github.com/user-attachments/assets/bd956662-21ce-4c4f-9c44-6afb4fd93755" />

<img width="1577" height="778" alt="scenario1_controller_states" src="https://github.com/user-attachments/assets/b54df58d-a0a9-42a3-aebf-ed5bba0867b8" />

https://github.com/user-attachments/assets/8a2a09dc-d78f-44a9-b79d-7e86cc9300fc

Excellent! The closed loop system is able to track the 1 meter X-axis reference command and converge within ~2 seconds while being under rotor thrust limits.

## Simulation Test Scenario #2: Yaw +60 deg relative to inertial frame

Next, the closed loop system is put to the test by applying a 60 deg yaw reference command. The following closed loop system response is shown below,

<img width="1576" height="1175" alt="scenario2_quadcopter_states" src="https://github.com/user-attachments/assets/52063ffb-bf5c-4d2f-8a63-80dbf9dd11ff" />

<img width="1571" height="782" alt="scenario2_controller_states" src="https://github.com/user-attachments/assets/6c5fd302-2626-421b-a6ce-5aa172a9733a" />

https://github.com/user-attachments/assets/ce896913-f2c4-4cb1-a40a-d9b280d8754b

Excellent! The closed loop system is able to track the 60 deg yaw reference command and converge within ~4 seconds while being under rotor thrust limits.

## Simulation Test Scenario #3: Track a 1m radius circular path at 1m altitude, while pointing the +X axis towards the center (orbit mode)

Next, the closed loop system is put to the test by tracking dynamic reference commands. The following closed loop system response is shown below,

<img width="1578" height="1179" alt="scenario3_quadcopter_states" src="https://github.com/user-attachments/assets/bb26af80-2c37-42de-b6c0-dd7cd7a6a228" />

<img width="1574" height="774" alt="scenario3_controller_states" src="https://github.com/user-attachments/assets/17d7afa0-8979-47ca-82fb-1a289fe306f4" />

https://github.com/user-attachments/assets/f80d654e-6196-41f7-a280-19619f3f9ebb

For this test scenario, the LQR lags behind the X and Y position commands and has steady error with the yaw command. This serves as a reminder that the Linear Quadratic **Regulator** is meant to regulate states back to the operating point and is not meant to track a dynamic reference, the LQR tracks really well for a static reference as seen in the two prior test scenarios above. To resolve the steady state yaw angle error, a common approach is to add an integrator term to the controller. 

##  Simulation Test Scenario #3 Repeat: New Control Strategy, the Linear Quadratic Integrator (LQI)

To add an integrator to the controller, we can integrate the yaw angle error by numerically summing up the yaw angle error, scaled by the time step, multiply the integrated error by a gain, and then add the final integrator result to our controller as analytically shown below,

$$
\mathbf{u} = -K \mathbf{x} - K_{i}\int_{0}^{t}(\mathbf{r} - \mathbf{x}\)dt
$$

Whenever adding an integrator term to a controller, it's good practice to apply a +/- clamping limit and optionally an activation region for when we want the integrator to kick in (e.g. if yaw angle error is < 5 deg, then start integrating the error). Both of these features are to avoid integrator windup and reduce overshoot from the "momentum" that the integrator has built up. The following closed loop system response is shown below,

<img width="1573" height="1169" alt="scenario3_quadcopter_states_yaw_integrator" src="https://github.com/user-attachments/assets/1a868abd-0816-4a94-9992-06f94fbd100a" />

<img width="1580" height="774" alt="scenario3_controller_states_yaw_integrator" src="https://github.com/user-attachments/assets/31c0466c-e5cc-4f70-9472-ffa2e190820f" />

https://github.com/user-attachments/assets/2e9e86d8-a4e4-442b-84ec-44e2dbbb21e4

Excellent! The integrator contribution improved the controller's ability to point towards the center of the circle and reduce the steady state yaw angle error to near zero. To improve the closed loop system's lag response with tracking the X and Y position commands, we can also include a rate command to the mix since we know analytically how the circle trajectory changes over time.

##  Simulation Test Scenario #3 Repeat: Addition of Reference Rate Command

To be continued... 
